

## Modes

- Standard: `/re/` (match it again and again throughout the whole document)
- Global: `/re/g`
- Case insensitive: `/re/i`
- Multiline: `/re/m`



## Grep

- comes from `g/re/p`
- Global regular expression print (globally search for the regex and print out the results)



## 1. Literal Characters

- Case-sensitive (by default)
- Advice: write all of your regexes as case sensitive
  - more compatible
  - hard to make mistakes

### Standard (non-global) matching

The earliest (leftmost) match is always preferred

`/zz` matches the first the first set of Zs in "pizzazz"

### Global matching

All matches are found through the text



> backrtracking



## 2. Metacharacters

- `\.*+-{}[]^$|?():!=`
- have more than one meaning (depend on context)



### Wildcard

`.` Any character except newline

- `/h.t` matches "hat", "hot", and "hit", but not "heat" (represent only one character)
- broadcast match possible
- most common mistake
  - `/9.00` matches "9.00", "9500", and "9-00"

### Escaping Metacharacters

`\` Escape the next character

- Allow use of metacharacters as literal characters
- Match a period with `/\./`
- `/9\.00/` matches "9.00", but not "9500" or "9-00"
- Match a backslash by escaping a backslash `(\\)`
- Only for metacharacters
- Literal characters should never be escaped
- Quotation marks are not metacharacter; do not need to be escaped

```perl
/\//
```

- escape `/` because it is used as delimiter in some programming languages

### Other Special Characters

- Spaces
- Tabs `\t`
- Line returns `\r`, `\n`, `\r\n`



### Challenge: Characters

1. Apply global regular expression to the text "Self-Reliance"

```perl
/Self-Reliance/g
```



2. How many times does the word "self" appear (include upper-case and lower-case)

```perl
/self/gi
# 64 times
```

3. Count: himself, herself, itself, myself, yourself, thyself

- himself: 20
- herself: no match
- itself: 12
- myself: 6
- thyself: 1

4. Using three literal characters and three wildcard characters, match: please, palace, parade

```perl
/p..a.e/gi
# 11 matches
```

5. What matches `/t..ch/` besides "teach"

```
ttach
to Ch
t, ch
touch
tarch
```



## 3. Character Sets

### Define a character set

`[` Begin a character set

`]` End a character set

- Any one of several characters
- **But only one character**
- Order of characters in the set does not matter
- `/aeiou/` matches any one vowel
- `\gr[ea]y\` matches "grey" and "gray"
- `\gr[ea]t\` does not match "great"

### Character ranges

`-` Ranges of characters

- includes all characters between two characters
- **Only a metacharacter inside a character set;** a literal dash otherwise
- [0-9]
- [A-Za-z]

**<font color=red>Caution</font>**

- [50-99] is not all numbers from 50 to 99
- It is the same as [0-9]
- A character set including 5, 0-9, and 9

### Negative character sets

`^` Negate a character set

- Not any one of several characters
- Add `^` as the first character inside a character set
- `/[^aeiou]/` matches any one consonant (non-vowel)
- `/see[^mn]/` matches "seek" and "sees" but not "seem" or "seen"

**<font color=red>Caution</font>**

- `/see[^mn]` does not match "see"
- `/see[^mn/]` does match "see." and "see "

### Metacharacters inside character sets

- Most metacharacters inside character sets are already escaped
- Do not need to escape them again
- `/h[a.]t/` matches "hat" and "h.t", but not "hot"
- Exceptions: `]`  `-`  `\`

```perl
/var[[(][0-9][\])]/
# escape "]"

/file[0\-\\_]1/
# escape "-" and "\"

/2013[-/]10[-/]05/
# May be able to use "-" as the first character in the character set without escaping it depending on Regex engine
```

### Shorthand character sets

| Shorthand | Meaning            | Equivalent    |
| --------- | ------------------ | ------------- |
| \d        | Digit              | [0-9]         |
| \w        | Word character     | [a-zA-Z0-9_]  |
| \s        | Whitespace         | [\t\r\n]      |
| \D        | Not digit          | [^0-9]        |
| \W        | not word character | [^a-zA-Z0-9_] |
| \S        | Not whitespace     | [^\t\r\n]     |

These aren't in all regex engines

**<font color=red>Caution</font>**

`\w`: [a-zA-Z0-9_)]

- Underscore is a word character
- **]** is not a word character
- `/[\w\-]/` matches any word character or hyphen (useful)

**Examples**

- `/\d\d\d\d/` matches "1984", but not "text"
- `/\w\w\w/` matches "ABC", "123", and "1_A"
- `/\w\s\w\w/` matches "I am", but not "Am I"
- `\[^\d]\` is the same as both `/\D/` and `/[^0-9]/`

**<font color=red>Caution</font>**

- `/[^\d\s]/` is not the same as `/[\D\D]/`

- `/[^\d\s]/` = Not digit OR space character (都不是)
- `/[\D\S]/` = EITHER NOT digit OR NOT space character (不是这个，或者不是那个，范围很大)

```perl
1234 5678 abc

/[^\d\s]/g
# Output: abd

/[\D\S]/g
# Output: 1234 5678 abc
```

### Challenge: Character sets

1. Match both "lives" and "lived"

   ```perl
   /live[sd]/g
   # 7 matches
   ```

   

2. Match "virtue" but not "virtues"

```perl
/virtue[^s]/g
# 14 matches
```

**However, the problem of this is it actually matches "virtue " with a whitespace! Whitespace is also a character.**



3. Match the numbers and periods on all numbered paragraph

```perl
/\d\./g
# 4 mathces
```



4. Find the 16-character word that starts with "c"

```perl
/[\W]c[a-z]{15}/g
# circumnavigation

# Solution:
# /c\w\w\w\w\w\w\w\w\w\w\w\w\w\w\w/g
# Cannot use /\c./ because it will also match c (whitespace)
```



## 4. Repetition

| Metacharacter | Meaning                            |
| ------------- | ---------------------------------- |
| *             | preceding item, zero or more times |
| +             | preceding item, one or more times  |
| ?             | preceding item, zero or one time   |

- `/.+/`  matches any string of characters except a line return (There's something here, but I don't care what they are)
- `/Good.+\.` matches "Good morning.", "Good day.", and "Good evening."
- `/\d+/` matches "90210"
- `/\s[a-z]+ed\s/` matches lowercase words ending in "ed" 然后前后各有一个whitespace
- `/apples*/` matches "apple", "apples", and "applesssss"
- `/apples+/` matches "apples" and "applessss", but not "apple"
- `/apples?/` matches "apple" and "apples", but not "applessss"
- `/\d\d\d\d*/` matches numbers with three digits or more
- `/\d\d\d+/` matches numbers with three digits or more
- `/colou?r/` matches "color" and "colour" (useful when you have words that might be spelled in different ways)

### Quantified repetition

| Metacharacter | Meaning                                       |
| ------------- | --------------------------------------------- |
| {             | Start quantified repetition of preceding item |
| }             | End quantified repetition of preceding item   |

**{min,max}**

- min and max are positive numbers
- min must always be included and can be zero
- max is optional

**Three syntaxes**

- `\d{4,8}` matches numbers with four to eight digits
- `\d{4}` matches numbers with exactly four digits (min is max)
- `\d{4,}` matches numbers with four or more digits (max is infinite)
- `\d{0,}` is the same as `\d*`
- `\d{1,}` is the same as `\d+`
- `\d{3}-\d{3}-\d{4}` matches most US phone numbers (commonly used in standard data where numbers match as specific pattern)
- `/A{1,2} bonds/` matches "A bonds" and "AA bonds", not "AAA bonds"

### Greedy Expressions

```
/\d+\w+\d+/
01_FY_07_report_99.xls

/".+", ".+"/
"Milton", "Waddams", "Initech, Inc."
```

- standard repetition quantifiers are greedy
- Expression tries to match the longest possible string
- Defers to achieving overall match
- `/.+\.jpg/` matches "filename.jpg"
- The `+` is greedy, but "gives back" the ".jpg" to make the match
- Gives back as little as possible
- `/.*[0-9}+/` matches "Page 266"
- `.*` portion matches "Page 26"
- `[0-9]+` portion matches only "6"
- Match as much as possible before giving control to the next expression part

**/\d+\w+\d+/**

**<font color=pink>01_FY_07_report_99</font>.xls**

**/".+", ".+"/**

**<font color=pink>"Milton", "Waddams",</font> <font color=green>"Initech, Inc."</font>**

**Eager and Greedy**

- Regex engines are eager
- Regex engines are greedy

### Lazy expression

| Metacharacter | Meaning                        |
| ------------- | ------------------------------ |
| ?             | Make preceding quantifier lazy |

- `*?`
- `+?`
- `{min,max}?`
- `??`
- Instructs quantifier to use a "lazy strategy" for making choices
- Match as little as possible before giving control to the next expression part
- Still defers to overall match
- Not necessarily faster or slower

**/.*?9[0-9]+/**

**<font color=green>Page </font><font color=blue>266</font>**

**/.*?[0-9]+?/**

**<font color=green>Page </font><font color=blue>2</font>66**

**/\d+\w+\d+/**

**<font color=pink>01_FY_07_report_99</font>.xls**

**/\d+\w+?\d+/**

**<font color=pink>01_FY_07</font>_report_99.xls**

**/".+", ".+"/**

**<font color=pink>"Milton", "Waddams",</font> <font color=green>"Initech, Inc."</font>**

**/".+?", ".+?"/**

**<font color=pink>"Milton", </font><font color=green>"Waddams"</font>, "Initech, Inc."**

### Challenge: Repetition

1. Match: self, himself, herself, itself, myself, yourself, thyself

```perl
/\w*self/g
# 61 matches
```

2. Match both "virtue" and "virtues"

```perl
/virtues?/
# 16 matches
```

2. Match both "virtue" and "virtues"

```perl
/virtues?/g
```

<font color=red>3. Use quantifies repetition to find the work that starts with "T" and has 12 letters</font>

```perl
/T\w{11}/g
# Tranquillity
```

<font color=red>4. Match all text inside quotation marks, but nothing that is not inside them</font>

```perl
/"(.|\n)+?"/g
# 12 matches
```



## 5. Grouping and Alternation

| Metacharacter | Meaning                  |
| ------------- | ------------------------ |
| (             | Start grouped expression |
| )             | End grouped expression   |

### Grouping metacharacters

- Group portions of the expression
- Apply repetition operators to a group
- Create a group of alternation expressions
- Captures group for use in matching and replacing

**<font color=red>Unlike character sets, it's not just a single character that's been repeated, but a group of characters that's been repeated</font>**

- `/(abc)+/` matches "abc" and "abcabcabc"
- `/(in)?dependent/` matches "independent" and "dependent" (**Another good use is to make something optional**)
- `/run(s)?/` is the same as `/runs?/`

**Use Cases**

1. apply repetition operators
2. alternation
3. capturing for replacing

#### Capturing for replacing

![image-20200318131318050](C:\Users\JY\AppData\Roaming\Typora\typora-user-images\image-20200318131318050.png)

some of engines use `\` instead of `$` 

### Alternation metacharacter

| Metacharacter | Meaing                            |
| ------------- | --------------------------------- |
| \|            | Match previous or next expression |

- `|` is an OR operator
- Either match expression on the left or match expression on the right
- Ordered, leftmost expression gets precedence
- Multiple choices can be daisy-chained
- Group alternation expression to keep them distinct
- `/apple|orange/` matches "apple" and "orange"
- `/abc|def|ghi|jkl/` matches "abc", "def", "ghi", "ijk"
- `/apple(juice|sauce)/` is not the same as `/applejuice|sauce/`
- `/w(ei|ie)rd/` matches "weird" and "wierd" (useful when things might be spelled in different ways)
- `/AA|BB|CC|DD/` would match any combination, like "AABBAACC" and "CCCCBBBB"

### Efficiency when using alternation

- regex engines are eager
  - **/(peanut|peanutbutter)/**
  - **<font color=green>peanut</font>butter**
  - as soon as it finds something that satisfies it, it's eager to return that result to you

- regex engines are greedy
  - **/peanut(butter)?/**
  - **<font color=green>peanutbutter</font>**
  - can be peanutbutter and peanut. It will take the whole thing since it's greedy by default
  - unless we tell it to be lazy, `/peanut(butter)??/`
  - **<font color=green>peanut</font> butter**, then it will give up as soon as it can

**/(xyz|abc|def|ghi|jkl)/**

**<font color=green>abc</font>defghijklmnopqrstuvwxyz**

- **<font color=red>put simplest (most efficient expression first</font>**
- `/\w+_\d{2,4}|\d{4}_export|export_\d{2}/` (not good)
- `/export_\d{2}|\d{4}_export|\w+_\d{2,4}/` better

### Challenge: Grouping and alternation

1. Match "myself", "yourself", "thyself", but not "himself", "herself", "itself"

```perl
/(my|your|thy)self/g
# 14 matches
```

2. Match "good", "goodness", and "goods" without typing "good" more than once

```perl
/good(ness|s)?/g
# 23 matches
```

3. Match "do" or "does" followed by "no", "not", or "nothing", even when it occurs at the start of a sentence

```perl
/[Dd]o(es)? (nothing|not|no)/g
/[Dd]o(es)? no(t(hing)?)?/g
/[Dd]o(es)? no(thing|t)?/g
```

However, `/[Dd]o(es)? no(t|thing)?/g` will miss "nothing"!!! So does `/[Dd]o(es)? (no|not|nothing)g`



## 6. Anchors

| Metacharacter | Meaning                            |
| ------------- | ---------------------------------- |
| ^             | Start of string/line               |
| $             | End of string/line                 |
| \A            | Start of string, never end of line |
| \Z            | End of string, never end of line   |

### Start and end anchors

`\A` and `\Z` are not supported by old and JS engines

- Reference a position, not an actual character
- Zero-width
- `/^apple/` or`/\Aapple/`
- `/apple$/` or `/appke\Z/`
- `/^apple$/` or `/\Aapple\Z/`

**/\w+@\w+\.[a-z]{3}/**

- **someone@nowhere.com**-junk

- pass validation

**/^\w+@\w+\.[a-z]{3}$/**

- It doesn't match anymore
- fails validation

By using start and end archers, we can ensure the string we're validating matches our entire regex.

### Line breaks and multiline mode

**Single-line mode**

- `^` and `$` do not match at line breaks
- `\A` and `\Z` do not match at line breaks

**Multiline mode**

- `^` and `$` will match at the start and end of lines
- `\A` and `\Z` do not match at line breaks

![image-20200318152703680](C:\Users\JY\AppData\Roaming\Typora\typora-user-images\image-20200318152703680.png)

### Word boundaries

| Metacharacter | Meaning                           |
| ------------- | --------------------------------- |
| \b            | Word boundary (start/end of word) |
| \B            | Not a word boundary               |

- Reference a position, not an actual character
- Before the first word character in the string
- After the last word character in the string
- Between a word character and a non-word characte
- Word characters: [A-Za-Z0-9_]
- `/\b\w+\b/` finds four matches in "This is a test
- `/\b\w+\b/` matches all of "abc_123" but only part of "top-norch"
- `/\bNew\bYork\b/` does not match "New York"
- `/\bNew\b\bYork\b/` matches "New York"
- `/\B\w+\B/` finds two matches in "This is a test" ("hi" and "es")

By adding word boundaries, we can narrow down the choices we have and become more efficient

### Challenge: Anchors

1. How many paragraphs start with "I" as in "I read"?

```perl
/^I\b/gm
# 4 matches
```

2. How many paragraphs end with a question mark?

```perl
/\?$/gm
# 1 mathches
```

3. <font color=red>Match all words with exactly 15 letters, including hyphenated word</font>

```perl
/\b[-\w]{15}\b/g
# 7 matches
```



## Reference

[1] LinkedIn course: [Learning Regular Expressions](https://www.linkedin.com/learning/learning-regular-expressions-2/next-steps?u=2288114) by Kevin Skoglund